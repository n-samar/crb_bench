\section{Introduction}\label{sec:introduction}

\figUsecase

In an increasingly data-driven world, privacy concerns and the need for secure
computation have become paramount. Fully Homomorphic Encryption (FHE) presents
a groundbreaking solution that allows computations to be performed directly on
encrypted data, without revealing the underlying information. With FHE,
individuals and organizations can perform complex operations on sensitive data
while preserving confidentiality, opening up exciting possibilities for secure
data processing in cloud environments, collaborative analytics, and private
machine learning.

However, FHE implementations suffer from a significant computational overhead
due to the complex mathematical operations required for encryption, decryption,
and homomorphic evaluation. As a result, practical adoption of FHE remains
limited, especially when considering the resource-constrained nature of central
processing units (CPUs) commonly found in everyday computing devices. Efficient
CPU performance is crucial for achieving acceptable execution times and making
FHE practical in real-world scenarios.

This paper aims to provide a comprehensive evaluation of CPU performance for
fully homomorphic encryption schemes. We will investigate various aspects of
CPU performance, including the impact of encryption parameters, algorithmic
complexities, and the interplay between FHE and parallel processing.
Furthermore, we will explore potential optimizations and trade-offs to improve
the efficiency and scalability of FHE on CPUs, considering factors such as
circuit depth reduction, SIMD (Single Instruction, Multiple Data)
vectorization, and hardware accelerators.

By analyzing and comparing the performance characteristics of different FHE
schemes on CPUs, this research intends to shed light on the practicality of
using FHE in resource-limited environments. Furthermore, we seek to identify
key challenges and propose strategies to overcome the computational bottlenecks
associated with FHE, ultimately facilitating its broader adoption and unlocking
its full potential in preserving privacy and enabling secure computation.

The goal of this project will be to see how fast ChangeRnsBase can run in
software.

Existing software libraries implement less-performant FHE schemes that do not
have the ChangeRnsBase bottleneck.
While these libraries avoid the
ChangeRnsBase, the total amount of both data movement and compute is actually
higher than when the ChangeRnsBase is used\cite{samardzic:isca22:craterlake}.
Further, the ChangeRnsBase is amenable to parallelism as it has a
computationally meaty kernel inside a trivially parallelizable loop.
When the ChangeRnsBase is avoided, the opportunities for parallelism are less
obvious.

